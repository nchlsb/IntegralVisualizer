{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import { result, tex } from './expression';\r\n;\r\nimport { endSwitch, maxBy, minBy, orElse, range, sumBy, just, nothing } from \"./helpers\";\r\nimport * as katex from \"katex\";\r\nimport { each, onMount } from 'svelte/internal';\r\n// variables of graph \r\nconst DEFAULT_BOUND_MAGNITUDE = 10;\r\nlet xMaxBound = DEFAULT_BOUND_MAGNITUDE;\r\nlet xMinBound = -DEFAULT_BOUND_MAGNITUDE;\r\nlet yMaxBound;\r\n$: yMaxBound = orElse(maxBy(points.map(point => point.y), y => y), DEFAULT_BOUND_MAGNITUDE) + 1;\r\nlet yMinBound;\r\n$: yMinBound = orElse(minBy(points.map(point => point.y), y => y), -DEFAULT_BOUND_MAGNITUDE) - 1;\r\nlet integralUpperBound = DEFAULT_BOUND_MAGNITUDE;\r\nlet integralLowerBound = -DEFAULT_BOUND_MAGNITUDE;\r\nlet dx = 1;\r\nlet f;\r\n$: f = x => Math.sin(x);\r\nlet numberOfPoints = 100;\r\n// -10 -> 5\r\n// offset => 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\r\n// lowerBound + offset\r\n// -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5\r\nlet points;\r\n$: points = [...range(numberOfPoints).map(n => {\r\n        const x = xMinBound + (n * ((xMaxBound - xMinBound) / numberOfPoints));\r\n        return { x: x, y: f(x) };\r\n    }), { x: xMaxBound, y: f(xMaxBound) }];\r\nlet numberRectangles;\r\n$: numberRectangles = (integralUpperBound - integralLowerBound) / dx;\r\nlet riemannRectangles;\r\n$: riemannRectangles = range(numberRectangles).map(n => {\r\n    const x = integralLowerBound + (n * (integralUpperBound - integralLowerBound) / numberRectangles);\r\n    const y = f(x);\r\n    // SVG can't process negative height \r\n    return {\r\n        height: Math.abs(y),\r\n        width: dx,\r\n        lowerLeftCorner: { x: x, y: (y > 0) ? 0 : y }\r\n    };\r\n});\r\nconst functions = [\r\n    { id: 'const', implementation: (x) => 1, representation: 'f(x) = 1' },\r\n    { id: 'linear', implementation: (x) => x, representation: 'f(x) = x' },\r\n    { id: 'quadratic', implementation: (x) => x * x, representation: 'f(x) = x^2' },\r\n    { id: 'exponential', implementation: (x) => Math.exp(x), representation: 'f(x) = e^x' },\r\n    { id: 'sine', implementation: (x) => Math.sin(x), representation: 'f(x) = \\\\sin(x)' },\r\n    { id: 'cubic', implementation: (x) => (x - 1) * (x) * (x + 1), representation: 'f(x) = (x - 1)(x)(x + 1)' }\r\n];\r\nonMount(_ => {\r\n    for (let f of functions) {\r\n        katex.render(f.representation, document.getElementById(`${f.id}-label`), { output: 'mathml' });\r\n    }\r\n});\r\nfunction render(expression) {\r\n    switch (expression.kind) {\r\n        case 'Plus': return `(${render(expression.left)} + ${render(expression.right)})`;\r\n        case '1': return '1';\r\n        case 'Active': return '□';\r\n        case 'Inactive': return '■';\r\n    }\r\n    endSwitch(expression);\r\n}\r\nfunction turnActiveIntoPlus(expression) {\r\n    switch (expression.kind) {\r\n        case '1': return { kind: '1' };\r\n        case 'Inactive': return { kind: 'Inactive' };\r\n        case 'Active': return { kind: 'Plus', left: { kind: 'Active' }, right: { kind: 'Inactive' } };\r\n        case 'Plus': return { kind: 'Plus', left: turnActiveIntoPlus(expression.left), right: turnActiveIntoPlus(expression.right) };\r\n    }\r\n    endSwitch(expression);\r\n}\r\nfunction turnActiveInto1(expression) {\r\n    switch (expression.kind) {\r\n        case '1': return { kind: '1' };\r\n        case 'Inactive': return { kind: 'Inactive' };\r\n        case 'Active': return { kind: '1' };\r\n        case 'Plus': return { kind: 'Plus', left: turnActiveInto1(expression.left), right: turnActiveInto1(expression.right) };\r\n    }\r\n    endSwitch(expression);\r\n}\r\nfunction copyIncompleteExpression(expression) {\r\n    switch (expression.kind) {\r\n        case '1': return { kind: '1' };\r\n        case 'Inactive': return { kind: 'Inactive' };\r\n        case 'Active': return { kind: 'Active' };\r\n        case 'Plus': return { kind: 'Plus', left: copyIncompleteExpression(expression.left), right: copyIncompleteExpression(expression.right) };\r\n    }\r\n    endSwitch(expression);\r\n}\r\nfunction maybeGetLeft(expression) {\r\n    if (expression.kind === 'Plus') {\r\n        return just(expression.left);\r\n    }\r\n    return nothing();\r\n}\r\nfunction maybeGetRight(expression) {\r\n    if (expression.kind === 'Plus') {\r\n        return just(expression.right);\r\n    }\r\n    return nothing();\r\n}\r\nfunction turnFirstInactiveIntoActive(expression) {\r\n    const copy = copyIncompleteExpression(expression);\r\n    /*\r\n        iterativeInorder(firstNode)\r\n            s ← empty stack\r\n            node <- firstNode\r\n            while (not s.isEmpty() or node ≠ null)\r\n                if (node ≠ null)\r\n                    s.push(node)\r\n                    node ← node.left\r\n                else\r\n                    node ← s.pop()\r\n                    visit(node)\r\n                    node ← node.right\r\n    */\r\n    // let S be a stack\r\n    let stack = [];\r\n    // node <- firstNode\r\n    let node = just(copy);\r\n    while (stack.length !== 0 || node.kind !== 'Nothing') {\r\n        if (node.kind !== 'Nothing') {\r\n            stack.push(node.value);\r\n            node = maybeGetLeft(node.value);\r\n        }\r\n        else {\r\n            const value = stack.pop();\r\n            // visit\r\n            if (value.kind === 'Plus') {\r\n                if (value.left.kind === 'Inactive') {\r\n                    // Guaranteed to be the first found, because it's an in-order traversal\r\n                    value.left = { kind: 'Active' };\r\n                    break;\r\n                }\r\n                else if (value.right.kind === 'Inactive') {\r\n                    value.right = { kind: 'Active' };\r\n                    break;\r\n                }\r\n            }\r\n            node = maybeGetRight(value); // nullable expressionn\r\n        }\r\n    }\r\n    return copy;\r\n}\r\nlet expression = { kind: 'Active' };\r\n</script>\r\n\r\n<main>\r\n\t{#each functions as f, index}\r\n\t\t<label id={`${f.id}-label`} for={f.id}></label>\r\n\t\t{#if index === 0}\r\n\t\t\t<input id={f.id} type=\"radio\" bind:group={f} checked>\r\n\t\t{:else}\r\n\t\t\t<input id={f.id} type=\"radio\" bind:group={f}>\r\n\t\t{/if}\t\r\n\t{/each}\r\n\r\n\t<!-- <select>\r\n\t\t{#each functions as f, index}\r\n\t\t\t<option id={f.id} value={f.implementation} default={index === 0 ? true : false}></option>\r\n\t\t{/each}\r\n\t</select> -->\r\n\r\n\r\n\r\n\t<p id=\"nick\"></p>\r\n\t<button on:click={() => {expression = turnActiveIntoPlus(expression)\r\n\t\tkatex.render(render(expression),document.getElementById(\"nick\"), {output: \"html\"})} }> Add Plus </button>\r\n\t<button on:click={() => {expression = turnFirstInactiveIntoActive(turnActiveInto1(expression))\r\n\t\tkatex.render(render(expression),document.getElementById(\"nick\"), {output: \"html\"})} }> Add 1 </button>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\tShould be \\[ {tex} \\]\r\n\t\t</li>\r\n\r\n\t\t<li>\r\n\t\t\tShould be 143.1407 : ..... {result}\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\tRectangle Width {dx}\r\n\t\t\t<input type=\"range\" min=\"0.1\" step=\".1\" max={integralUpperBound - integralLowerBound} bind:value={dx}>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\tFunction\r\n\t\t\t<select bind:value={f}>\r\n\t\t\t\t<option default value={x => Math.sin(x)}>Sine</option>\r\n\t\t\t\t<option value={x => (x * x)}>Squared</option>\t\r\n\t\t\t</select>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\tType in here <input type=\"text\" on:input={x => {\r\n\t\t\t\t// f u, js\r\n\t\t\t\tconst brett = document.getElementById(\"brett\");\r\n\t\t\t\tkatex.render(x.currentTarget.value, brett, {output: \"html\"});\r\n\t\t\t}}>\r\n\t\t</li>\r\n\t\t<li id=\"brett\">\r\n\t\t\tOutput: \r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\tThe sum of the rectangles rounded to 1's place is {Math.round(sumBy(riemannRectangles, \r\n\t\t\t\trectangle => rectangle.width * rectangle.height))}\r\n\t\t</li>\r\n\t\t<li>{yMinBound} {yMaxBound}</li>\r\n\t</ul>\r\n\r\n\t<svg class=\"cartesian\" viewBox=\"{xMinBound} {yMinBound} {(xMaxBound - xMinBound)} {(yMaxBound - yMinBound) }\">\r\n\t\t<g>\r\n\t\t\t<!-- x and y axis -->\r\n\t\t\t<line stroke=\"black\" fill=\"none\" x1={xMinBound} y1=\"0\" x2={xMaxBound} y2=\"0\" />\r\n\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"0\" y1={yMinBound} x2=\"0\" y2={yMaxBound} />\r\n\r\n\t\t\t<!-- bounds of intergral -->\r\n\t\t\t<line stroke=\"black\" stroke-dasharray=\"2,2\" fill=\"none\" x1={integralLowerBound} y1={yMinBound} x2={integralLowerBound} y2={yMaxBound} />\r\n\t\t\t<line stroke=\"black\" stroke-dasharray=\"2,2\" fill=\"none\" x1={integralUpperBound} y1={yMinBound} x2={integralUpperBound} y2={yMaxBound} />\r\n\r\n\t\t\t<!-- rectangles -->\r\n\t\t\t{#each riemannRectangles as rectangle}\r\n\t\t\t\t\t<rect\r\n\t\t\t\t\t\tclass=\"riemann-rectangle\"\r\n\t\t\t\t\t\tx={rectangle.lowerLeftCorner.x}\r\n\t\t\t\t\t\ty={rectangle.lowerLeftCorner.y}\r\n\t\t\t\t\t\twidth={rectangle.width}\r\n\t\t\t\t\t\theight={rectangle.height}\r\n\t\t\t\t\t/>\r\n\t\t\t{/each}\r\n\r\n\t\t\t<!-- graph of function -->\r\n\t\t\t<polyline stroke=\"black\" fill=\"none\" points={points.map(point => `${point.x},${point.y}`).join(' ')} />\r\n\r\n\t\t</g>\r\n\t</svg>\r\n\r\n\t<input class=\"bound-range\" type=\"range\" min={xMinBound} max={xMaxBound} step=\".01\" bind:value={integralLowerBound}>\r\n\t<input class=\"bound-range\" type=\"range\" min={xMinBound} max={xMaxBound} step=\".01\" bind:value={integralUpperBound}>\r\n\r\n\t<input type=\"number\" max={xMaxBound - 1} bind:value={xMinBound}>\r\n\t<input type=\"number\" min={xMinBound + 1} bind:value={xMaxBound}>\r\n</main>\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\" integrity=\"sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\" crossorigin=\"anonymous\">\r\n<style>\r\n\tmain {\r\n\t\ttext-align: center;\r\n\t\tpadding: 1em;\r\n\t\tmax-width: 240px;\r\n\t\tmargin: 0 auto;\r\n\t}\r\n\r\n\th1 {\r\n\t\tcolor: #ff3e00;\r\n\t\ttext-transform: uppercase;\r\n\t\tfont-size: 4em;\r\n\t\tfont-weight: 100;\r\n\t}\r\n\r\n\t.riemann-rectangle {\r\n\t\tfill: gray;\r\n\t\tstroke: black;\r\n\t\tstroke-width: 1;\r\n\t}\r\n\r\n\tline, rect, polyline {\r\n\t\tstroke-width: 1px;\r\n\t\tvector-effect: non-scaling-stroke;\r\n\t}\r\n\r\n\t@media (min-width: 640px) {\r\n\t\tmain {\r\n\t\t\tmax-width: none;\r\n\t\t}\r\n\t}\r\n\r\n\t.bound-range {\r\n\t\twidth: 100%;\r\n\t}\r\n\r\n\tsvg.cartesian {\r\n\t\tdisplay: flex;\r\n\t\twidth: 100%;\r\n\t\theight: 400px;\r\n\t}\r\n\r\n\t/* Flip the vertical axis in <g> to emulate cartesian. */\r\n\tsvg.cartesian > g {\r\n\t\twidth: 100%;\r\n\t\ttransform: scaleY(-1);\r\n\t}\r\n\r\n\t/* Re-flip all <text> element descendants to their original side up. */\r\n\tsvg.cartesian > g text {\r\n\t\ttransform: scaleY(-1);\r\n\t}\r\n</style>"
  ],
  "names": [],
  "mappings": "AAkPC,IAAI,4BAAC,CAAC,AACL,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AASD,kBAAkB,4BAAC,CAAC,AACnB,IAAI,CAAE,IAAI,CACV,MAAM,CAAE,KAAK,CACb,YAAY,CAAE,CAAC,AAChB,CAAC,AAED,gCAAI,CAAE,gCAAI,CAAE,QAAQ,4BAAC,CAAC,AACrB,YAAY,CAAE,GAAG,CACjB,aAAa,CAAE,kBAAkB,AAClC,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,IAAI,4BAAC,CAAC,AACL,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC,AAED,YAAY,4BAAC,CAAC,AACb,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,GAAG,UAAU,4BAAC,CAAC,AACd,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,AACd,CAAC,AAGD,GAAG,wBAAU,CAAG,CAAC,cAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,OAAO,EAAE,CAAC,AACtB,CAAC"
}